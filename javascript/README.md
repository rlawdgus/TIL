# 자바스크립트 특징

-   인터프리터 - JIT(Just In Time) Compiler => 실행 속도 증가
-   동적 프로토타입 기반 객체 지향
-   동적 타입 - 실행 도중에 타입이 바뀐다
-   함수는 일급 객체 - 함수에 함수를 인수로 넘길 수 있다
-   함수가 클로저(변수 은닉, 영속성 보장) 정의

# window - 브라우저, 창 조작

# DOM - HTML 문서 요소 제어

# XMLHttpRequest - 비동기 통신 기능

# let, const - es6부터 추가된 변수 선언자

var, let 차이

-   let으로 선언헌 변수의 유효 범위는 블록 안
-   var은 블록 밖에서 읽어도 에러가 나지 않는다

# 익명함수(무명함수)

재사용하지 않을 때 사용, 호이스팅이 되지 않고 리터럴로 이름이 붙으면 재사용할 수 있다

# 객체 분류

-   네이티브 객체 - es사양에 정의된 객체, Object String Number Boolean Array Function JSON Math Reflect
-   호스트 객체 - 자바스크립트 실행 환경에 정의된 객체, Window Navigator History Location XMLHttpRequest API(HTML)
-   사용자 정의 객체

# new

1. 빈 오브젝트 생성
2. this를 오브젝트에 바인드
3. 오브젝트의 프로퍼티에 생성자 함수의 프로토타입 오브젝트(proto) 추가
4. 반환될 수 있도록 return this를 마지막에 추가

# ProtoType - 모든 오브젝트가 가지고 있고 여기서 메소드, 프로퍼티를 상속받는다

# this

-   함수가 호출되어 실행되는 시점에 this값이 결정, 그 함수가 속해 있던 객체 참조
-   최상위 레벨 - 전역 객체(Window)
-   이벤트 처리기 - 이벤트가 발생한 요소 객체
-   생성자 함수 - 그 생성자로 생성한 객체
-   protoType 메소드 - 그 생성자로 생성한 객체
-   직접 호출한 함수 - 코드 앞의 객체 없을 경우 전역 객체

# scope

-   변수 접근 범위
-   scope chain - 현재 스코프에 찾는 변수가 없을 때 상위 스코프에서 찾는다
-   lexical scope - 블록마다 가지는 스코프, 함수는 실행시에 렉시컬 스코프가 생긴다
-   closure
    -   함수가 생성되는 시점에 접근 가능 했던 변수들은 생성 이후에도 접근하는 기능
    -   변수 은닉, 지속성 보장
    -   데이터와 데이터를 조작하는 함수를 하나로 사용 가능
    -   다양한 매개변수를 쓰는 함수를 여러 개 생성 (팩토리)
    -   여러 번 실행시 두 번째 이후로는 연산 없이 연산 했던 결과 이용 (초기화)

# 함수 리터럴과 화살표 함수의 차이점

-   this의 값이 정의할 때 결정(함수 리터럴은 호출할 때)
-   arguments가 없음
-   생성자로 사용할 수 없음
-   내부에서 yield를 쓸 수 없음

# 이벤트 전파 과정

1. 캡처링
   Window객체에서 출발해서 DOM트리를 타고 이벤트 타겟(이벤트가 발생한 요소)까지 전파
2. 타겟
   이벤트가 이벤트 나겟에 전파되는 단계, 등록된 처리기나 리스너는 이 시점에서 실행
3. 버블링

-   이벤트가 이벤트 타겟에서 DOM트리를 타고 Window객체까지 전파
-   이벤트 리스너의 useCapture가 true면 캡처링, 타겟 단계일 때만 실행
-   false면 타겟, 버블링 단계일 때만 실행

# 동기, 비동기

-   데이터를 받는 방식
-   동기(동시에)
    -   요청과 결과가 동시에 일어남
    -   간단, 직관
    -   결과가 날 때까지 대기
-   비동기
    -   요청과 결과가 동시에 일어나지 않음
    -   복잡
    -   결과가 나는 동안 다른 작업 가능

# Promise

-   비동기 코드를 다루기 쉬운 형태로 만듦
-   상태
    -   pending: 대기중
    -   fulfilled: 실행 후 결과를 가지고 있음
    -   rejected: 실행이 비정상적으로 끝남
-   메소드
    -   resolve - 함수 안의 처리가 끝났을 때, Promise객체 매개변수
    -   reject - 함수 안의 처리가 실패했을 때, Promise객체 매개변수
    -   then(처리됨 상태의 처리, 거부됨 상태의 처리)
    -   catch - 프로미스 수행 중의 예외 처리, then의 두 번째 매개변수 처리와 같음
    -   finally - 성공, 실패 여부와 상관없이 실행, 새로운 Promise를 생성하지 않음
    -   all - 병렬처리, 비동기 함수간 의존성이 없어 병렬처리가 유리할 때 사용
    -   race - 가장 빨리 처리된 Promise 반환

# async, await

-   더 간결한 비동기 프로그래밍 코드
-   async
    -   일반 함수처럼 사용 가능
    -   Promise 객체로 사용 가능
    -   Promise를 반환한다(then같은 메소드 사용 가능)
    -   함수 내부에서 Promise를 반환하면 그 객체 그대로 반환
    -   함수 내부에서 예외 발생시 거부됨 상태의 Promise 반환
-   await
    -   await은 async 함수 내부에서만 쓸 수 있다
    -   Promise 반환
    -   피연산자의 값을 반환, Promise객체인 경우 then 이후 값 반환
    -   Promise가 처리될 때까지 기다린다 => 순차적인 코드

# GET

웹 서버에 페이지 요청, 필요한 데이터는 URL에 덧붙여(텍스트만 가능) 보냄

# POST

-   데이터 갱신할 때
-   데이터 량이 많을 때
-   비밀번호같은 개인정보를 보낼 때 사용
-   텍스트 바이너리 모두 가능

# Ajax

-   XMLHttpRequest라는 자바스크립트 객체를 이용하여 우베 서버와 비동기로 통신하고 DOM을 이용하여 웹페이지를 동적으로 갱신하는 프로그래밍 기법
-   최소한의 통신으로 처리 속도가 빠르고 서버, 트래픽 부하가 적다
-   클라이언트 측에서 다른 작업을 할 수 있다.
-   갱신을 클라이언트 측이 담당한다. 일부분만 변경하므로 고속 렌더링이 가능하다.
-   화면 전체를 전환하는 빈도가 줄어들어 편의성 제공

# XMLHttpRequest

-   Ajax 기법을 사용할 때 필요, 데이터 송수신 수단
-   객체 생성
-   서버와 통신할 때 처리 방법 등록
-   요청을 전송하고 통신을 시작
-   동일 출처 정책 준수 => 크로스 오리진 통신 불가 => JSONP, CORS, postMessage

# JSONP - JSON 데이터 + 함수명, 상속 비보안 문제로 CORS로 대체

# CORS(Cross Origin Resource Sharing)

-   도메인, 프로토콜, 포트가 다른 곳에 리소스 교환이 가능하도록 하는 기술
-   XMLHttpRequest level 1에서는 크로스 오리진 통신 금지이고 level 2에서는 제한적으로 허용하는데 이 사양을 CORS라 한다
-   데이터를 가져오는 대상의 신뢰도에 따라 허용
-   Access-Control-Allow-Origin이라는 HTTP 헤더를 추가해야 한다

-   외부 도메인 서버와 통신하기 위한 방식을 표준화
    클라이언트는 request header에 , 서버는 response header에 CORS옵션을 추가하면 된다
    특정 도메인만 허용하기도 가능

    웹 브라우저에 도메인 입력
    => 해당하는 서버로 요청
    => 서버에서 응답시 html 반환
    (추가 요청시 같은 도메인에서 일어나므로 요청 가능)

    웹 서버에 API를 두고 통신하면 가능하나
    서버를 거치지 않고 할 수 없을까 (웹사이트와 API가 도메인이 다르므로 x)

    URL - 도메인 이름(ip 주소를 사람이 알아 볼 수 있게 이름을 붙임) or ip 주소
    웹 브라우저 - 웹을 볼 수 있게 하는 프로그램
    브라우저 기본 정책 - 도메인이 다르면 요청을 주고받을 수 없게 한다

# postMessage

open으로 창을 열면 부모 창과 자식 창이 서로 Window객체를 참조해 조작할 수 있
두 창 서로 페이지 출처가 다르기 때문에 상대의 콘텐츠를 가져올 수 없는
postMessage로 메세지를 비동기적으로 주고받을 수 있다(프로퍼티 참조, 메소드 실행은 불가)

# MVC 모델

-   Model - 데이터와 처리 로직
-   View - 사용자가 볼 수 있는 형태로 표현
-   Controller - 사용자의 입력을 메세지로 전달

# Web Workers

자바스크립트에서 멀티스레드로 병렬 처리를 할 수 있는 API

# in JS 33 Concepts

## 1. 단일 콜스택, 9. 이벤트 루프

-   싱글 스레드 => 한 번에 1개의 작업

-   V8 내부 - 힙, 큐, 스택(콜 스택)

-   힙 오브젝트(객체)등 메모리 할당

-   큐
    메세지 큐
    콜백함수등 실행될 메세지 리스트
    스택이 공간을 갖고 있을 때 메세지 디큐 => 메세지가 가지고 있던 함수 실행

-   스택(단일 콜 스택)
    함수 실행(push)
    반환(pop)

-   네트워크 요청, 서버 요청 - AJAX
    이 요청을 동기화 함수로 실행한다면 실행하는 동안 다른 일을 할 수 없음 (싱글 스레드)

-   비동기 실행 방식

    1. DOM 이벤트, http 요청, setTimeout같은 비동기 이벤트들을 브라우저의 스레드(C++로 구현) API 호출
    2. 그 결과들을 인큐(만약 바로 스택에 넣으면 결과가 랜덤하게 나온다)
    3. 이벤트 루프(브라우저, nodejs)가 스택이 비어있는지 확인하고 큐의 첫 번째 메세지를 푸시한다

    브라우저 구조
    자바스크립트
    힙 - 객체등 메모리 할당
    스택 - js 실행을 위한 싱글스레드
    브라우저(웹) API - 비동기 작업 실행, 큐로 결과나 메세지 인큐
    큐 - 이벤트 루프에 의해 스택으로 디큐
    이벤트 루프 - 자바스크립트 스택 상태 확인 후 비었을 시 디큐, 푸시

## 2. 원시타입, 3. 값 참조

-   객체가 아닌 것(boolean, null, undefined, number, string, symbol(ES6))
-   불변적(재할당과는 다른 개념, 값 자체는 절대 바뀔 수 없다)
-   값 저장(객체는 참조 저장)
-   Object
    함수(1급 객체 - 할당됨, 인자값으로 넘겨짐, 반환됨)
    메소드(property)
    생성 함수(object 반환)
-   래퍼 오브젝트 - 원시타입이면서 객체(new String ...)
-   자바스크립트 내부에 오토박싱이라는 기능 때문에 string, number, boolean은 객체처럼 동작한다

## 4. 암묵적 타입 변환

-   숫자 문자(소숫점, "1", "2", ...)를 포함해 연산 => 숫자(숫자가 아닌 것이 있으면 NaN)
-   +는 수학적 덧셈, 문자열 합치기, 숫자를 문자로 바꾸려 함
-   객체(toString을 가짐)일 때 수학적 표현식(\*, / ...)이 있으면 숫자로, 아니면 문자열로 변환, toString과 valueOf를 다 가지고 있으면 valueOf 사용
-   배열은 반점을 추가한 문자열(join과 비슷) 반환, 숫자 문자 하나 있을 경우 연산(빈 것은 0)
-   true => 1, false => 0
-   falsy(false로 변환) => false, 0, null, undefined, "", NaN, -0
-   truthly(true로 변환) => falsy 제외 모두
-   NaN !== NaN, isNaN()으로 판단

## 5. ==, ===, typeof

-   === => 타입, 내용이 모두 같을 때 true
-   == => 형변환 후 같을 때 true
-   NaN == (any) => false, NaN == NaN => false

## 6. scope (접근 가능 범위)

-   일반적인 규칙과 비슷하나 호이스팅 되지 않음
-   클로저 - 선언 시 스코프를 기억하여 스코프 밖에서 실행될 때에도 이 스코프에 접근할 수 있게 하는 기술
    (외부 함수가 소멸됐어도 내부 함수가 외부 함수에 접근할 수 있는 권한을 갖는다)

## 7. 표현식(expression), 문장(상태, statement)

-   표현식은 값 반환(값, 변수, 연산자 조합), 문장은 명령(if else, while, ...)
-   표현식 + ; == 표현식 문장
-   표현식은 문장처럼 동작할 수 있는데 문장은 표현식처럼 동작할 수 없다
-   표현식 묶을 땐 (), 문장을 묶을 땐 {}

## 8. IIFE

-   함수를 식으로 변환하고 즉시 실행

    (func () {}()) === (func () {})()

## 10. 스케줄링

-   setTimeout(func, 1000) or setTimeout(() => func(arg1, ...), 1000)
    setTimeout(func(arg1,..), 1000) => func 함수를 실행시켜서 func의 실행결과가 전달됨

-   clearTimeout(timerId)
    setTimeout은 timer identifier를 반환함
    clearTimeout을 쓰기 위해선 timer id를 인자로 넘겨야 함

-   setInterval(func, 1000) or setInterval(() => func(arg1, ...), 1000)

-   clearInterval(timerId)
    setInterval도 timer identifier를 반환하므로 이를 넘겨야 함

-   재귀적 setTimeout
    setInterval처럼 주기적인 실행
    setInterval실행시 인자로 넘긴 텀은 함수 실행시간 포함 (함수 실행시간의 차이만큼 텀도 차이가 남)
    재귀적 setTimeout은 함수 실행시간을 포함하지 않기 때문에 확정적인 텀을 줄 수 있음
    상황에 따라 유연하게 텀을 주는 것도 가능

-   setTimeout(func, 0) => 비동기적으로 실행을 위한 코드

## 13. DOM
